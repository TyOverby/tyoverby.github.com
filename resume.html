<!doctype <!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Ty Overby - Resume</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" media="screen" href="./css/resume.css" />
    <link rel="stylesheet" type="text/css" media="print" href="./css/resume.css" />
    <link rel="stylesheet" type="text/css" media="print" href="./css/printspecific.css" />
</head>

<body>
    <article id="cover">
        <div id="left">
            <div id="name"> Ty Overby </div>
            <section id="experience">
                <h2> Experience </h2>
                <div class="detail">
                    <span class="main">Microsoft</span>
                    <span class="follow">Redmond</span>
                    <span class="sep">Software Developer 2</span>
                    <span class="last">Autumn 2015 - now</span>
                </div>
                <p>
                    As a developer on the
                    <strong>Roslyn Compiler</strong> for C# and Visual Basic I participated in language design, implemented language
                    features, found/fixed bugs, and worked on improving the user experience for the compiler developers and
                    users on Linux. I took the "async Main" language feature from concept to its release in C# 7.1.
                </p>

                <p>
                    As a member of an internal
                    <strong>"Infrastructure Swat Team"</strong> I spent roughly &#8531; of my time on point for all performance investigations
                    in the product. While conducting performance analysis, I learned how to debug from heap dumps as well
                    as how to collect and analyze performance traces on Windows. Because of my involvement, Visual Studio
                    was able to ship on time and with fewer perf regressions. Before switching teams internally, I successfully
                    trained another employee to take over my position.
                </p>

                <p>
                    As a developer on the
                    <strong>
                        <code>try.dot.net</code>
                    </strong>
                    team, I helped build and maintain a full stack service for evaluating C# from the browser. It required frontend development
                    for the web portal (Typescript and React/Redux), backend web servers / services in C#, and integration
                    with many Azure services. While preparing for a major conference where our software would be demoed,
                    I built a simulator for evaluating the reliability of our service under heavy load. This simulator discovered
                    a flaw in our scaling algorithm which we were able to fix in time for the conference.
                </p>

                <div class="detail">
                    <span class="main">Google</span>
                    <span class="follow">Seattle</span>
                    <span class="sep">Software Developer Intern</span>
                    <span class="last">Summer 2014</span>
                </div>
                <p>
                    As an intern on the
                    <strong>Dart language compiler</strong>, I instrumented the compiler to produce metadata alongside a compilation.
                    I also built an in-browser visualizer that consumed the metadata produced at compilation. With the metadata
                    and visualizer, it became possible to answer questions about the compilation such as "what is the inferred
                    type of this variable", "why was this function not tree-shaken out of the compilation", and "which functions
                    are the most responsible for code bloat after tree shaking occurrs".
                </p>

                <div class="detail">
                    <span class="main">Google</span>
                    <span class="follow">Seattle</span>
                    <span class="sep">Software Developer Intern</span>
                    <span class="last">Summer 2013</span>
                </div>
                <p>
                    As an intern on the
                    <strong>Google Chrome Audio/Video</strong> team, I built a diagnostics tool inside of Chrome for collecting and
                    reporting information about the media streams that are currently live in the browser. This tool is still
                    available at
                    <code>chrome://media-internals/</code>
                </p>
            </section>
            <section id="education">
                <h2>Education</h2>
                <div class="detail">
                    <span class="main">University of Washington</span>
                    <span class="follow">Seattle</span>
                    <span class="sep">BS in Computer Science</span>
                    <span class="last">June 2012 - May 2015</span>
                </div>
            </section>
        </div>
        <div id="right">
            <div id="contact">
                <ul>
                    <li> tyoverby.com </li>
                    <li> github.com/tyoverby </li>
                    <li> (253) 514-9370 </li>
                    <li> ty@pre-alpha.com </li>
                </ul>
            </div>
            <section id="tools">
                <h2> Tools </h2>
                <p>
                    I know enough about
                    <strong>Git</strong> to get coworkers (and myself) out of tricky situations.
                </p>
                <p>
                    5 years of using
                    <strong>Rust</strong> and I'm still loving every day of it!
                </p>
                <p>
                    Professional experience developing, debugging and profiling
                    <strong>C#</strong>,
                    <strong>Visual Basic</strong> and
                    <strong>F#</strong>.
                </p>
                <p>
                    Over a decade of
                    <strong>Linux</strong> (Debian and Ubuntu ) on the desktop, 9 years of
                    <strong>OS&nbsp;X</strong> on a macbook, and 3 years of
                    <strong>Windows</strong> at work for development.
                </p>
            </section>
            <section id="interests">
                <h2>Interests</h2>
                <p>
                    Ever since I started programming I've been interested in
                    <strong>programming languages</strong>
                    and how they can be made more user friendly. I've worked on countless personal language experiments and several production
                    <strong>compilers</strong> and their IDE tooling.
                </p>
                <p>
                    After learning some
                    <strong> GPU programming </strong> in order to make a CAD program for laser cutters, I've been interested in using
                    the GPU to speed up other traditional programs.
                </p>
                <p>
                    I'm a hobby
                    <strong>carpenter</strong> and
                    <strong>leather worker</strong> in need of a workshop!
                </p>
            </section>
        </div>
    </article>
    <article id="continued">
        <section id="personal-projects">
            <h2>Personal Projects</h2>
            <div class="detail">
                <span class="main">Bincode</span>
                <span class="follow">github.com/tyoverby/bincode</span>
                <span class="sep">Rust</span>
                <span class="last">September 2014 - Present</span>
            </div>
            <p>
                Bincode is a Rust project for serializing and deserializing structures to and from a binary format. Because it takes advantage
                of some compile-time features of Rust, it can generate an encoding scheme specifically for each struct that
                it needs to work with! This means that it can avoid emiting structural information into the output leading
                to very small serlization sizes and fast serialization and deserialization.
            </p>
            <p>
                Bincode has been used in production by a multitude of projects including
                <ul>
                    <li>
                        <strong>google/tarpc</strong>: Bincode is used to serialize and deserialize networked RPC messages.
                    </li>
                    <li>
                        <strong>servo/webrender</strong>: Bincode records webrender API calls for record/replay-style graphics debugging.
                    </li>
                    <li>
                        <strong>servo/ipc-channel</strong>: Ipc-Channel uses Bincode to send structs between processes using a channel-like
                        API.
                    </li>
                </ul>

                I'm especially excited to start tuning bincode for the
                <strong>Firefox/Quantum</strong> work where (to my understanding) Bincode will be the format for transfering GPU
                commands between processes.
            </p>

            <div class="detail">
                <span class="main">Implicit</span>
                <span class="follow">github.com/tyoverby/implicit-gpu</span>
                <span class="sep">Rust, TypeScript, OpenCL</span>
                <span class="last">December 2016 - Present</span>
            </div>
            <img src="./images/implicit.png" width=300 />
            <p>
                Implicit is the latest iteration of a 2D CAD (Computer Aided Design) program that I've been developing for use with laser
                cutters and pen plotters. It features a TypeScript API where the user designs their shape in a purely functional
                style building shapes out of other shapes using Constructive Solid Geometry by representing these shapes
                as Implicit Surfaces.
            </p>
            <p>
                Because of the nature of Implicit Surfaces, sampling the equation at millions of points is required in order to get paths
                for vectorization. This sampling is often the bottleneck in large drawings, so I've experimented with many
                versions in order to achieve the performance that I need. These experiments include:
                <ul>
                    <li>
                        <strong>Thread-Based Parallelization</strong> using the Rust parallelization library Rayon.</li>
                    <li>
                        <strong>Instruction-Level Parallelization</strong> using SIMD.</li>
                    <li>Compiling the Implicit Surface formulas to
                        <strong>OpenCL</strong> and then evaluating them on the GPU</li>
                    <li>Compiling the formulas to machine code via a
                        <strong>JIT Compiler</strong>
                    </li>
                </ul>

                The interface for the CAD software is an in browser IDE written in TypeScript and React. It has an in-browser editor with
                autocomplete and diagnostics, and a live preview of the scene that is being rendered. When launched in developer
                mode, the IDE comes with an integrated performance visualizer - great for finding out why an operation took
                longer than expected!
            </p>
            <div class="detail">
                <span class="main">Flame</span>
                <span class="follow">github.com/tyoverby/flame</span>
                <span class="sep">Rust, TypeScript, React </span>
                <span class="last">October 2015 - Present</span>
            </div>
            <p>
                Flame is a library for adding intrusive profiling to a Rust program. While externally-run profilers like Linux
                <code>perf</code> or Windows
                <code>PerfView</code> are great, they often overload the user with data, making them tools to be used only in the last resort.
                With Flame, a programmer would instrument their code with calls that denote logically separate regions of
                code. Then Flame can produce timeline based flamegraphs containing just the regions that programmer instrumented.
            </p>
            <p>
                While I've had great experiences using Flame in other projects, the core model for Flame falls over in the presense of asynchronous
                code. For this reason, Flame is currently under redesign.
            </p>
            <img src="./images/flame.png" height=100 />
            <p>
                <strong>Fireplace</strong> is a browser based visualizer for the flamegraph data produced by Flame. It supports viewing
                performance data across multiple threads and can be embedded in other projects for quick performance debugging.
            </p>

        </section>
    </article>
</body>

</html>
