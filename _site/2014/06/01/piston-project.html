<!DOCTYPE html>
<html>
    <head>
        <title> What is the Piston Project </title>
        <link rel="stylesheet" type="text/css" href="/css/style.css">
        <link rel="stylesheet" type="text/css" href="/css/code.css">
    <link href="http://fonts.googleapis.com/css?family=Cardo:700" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">
    </head>
    <body>
        <div id="wrapper">
            <header>
    <h1> What is the Piston Project </h1>
    <h2>  </h2>
    <div id="byline"> <span> By </span> <span>  </span> </div>
</header>

<div id="post">
    <h1>This is a rough draft.</h1>

<h1>Do not distribute</h1>

<p>The Piston Project is a collection of game programming libraries that make it
easy to develop games in the Rust programming language.  These libraries are
made with the intent of being combined and extended very easily.</p>

<p>Let&#39;s take a look at a few of the libraries in the Piston Project.</p>

<h2>Piston</h2>

<p>As any native game developer knows, getting a window open and a triangle on
the screen can be hell.  The titular project <em>Piston</em> helps with the first
of those by providing a clean, backend-independent windowing API.  The API
can be backed by SDL2, GLFW, (those are the two that the Piston Project
provides), or any other system that another party decides to write that
implements the <em>Piston</em> API.</p>

<p>Aside from just creating a window, <em>Piston</em> exposes an interface for
keyboard and mouse events, making interacting with the window just as easy
as opening it.</p>

<p>Let&#39;s take a look at the code that it takes to get a window up on the screen.</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="n">crate</span> <span class="n">piston</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">crate</span> <span class="n">sdl2_game_window</span><span class="p">;</span>

<span class="c1">// This would contain our game state</span>
<span class="k">struct</span> <span class="n">App</span><span class="p">;</span>

<span class="c1">// This would contain our game behavior</span>
<span class="k">impl</span> <span class="n">Game</span> <span class="k">for</span> <span class="n">App</span> <span class="p">{}</span>

<span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="k">mut</span> <span class="n">window</span> <span class="o">=</span> <span class="n">GameWindowSDL2</span><span class="o">::</span><span class="n">new</span><span class="p">(</span>
        <span class="n">GameWindowSettings</span> <span class="p">{</span>
            <span class="n">title</span><span class="o">:</span> <span class="s">&quot;test&quot;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span>
            <span class="n">size</span><span class="o">:</span> <span class="p">[</span><span class="mi">800</span><span class="p">,</span> <span class="mi">400</span><span class="p">],</span>
            <span class="n">fullscreen</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
            <span class="n">exit_on_esc</span><span class="o">:</span> <span class="k">true</span>
        <span class="p">}</span>
    <span class="p">);</span>

    <span class="kd">let</span> <span class="n">game_iter_settings</span> <span class="o">=</span> <span class="n">GameIteratorSettings</span> <span class="p">{</span>
        <span class="n">updates_per_second</span><span class="o">:</span> <span class="mi">120</span><span class="p">,</span>
        <span class="n">max_frames_per_second</span><span class="o">:</span> <span class="mi">60</span>
    <span class="p">};</span>
    <span class="n">App</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">game_iter_settings</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>You&#39;ll notice that the SDL2 backend was used for this example. How and why
is a bit out of scope for this introduction, but will be covered by the
tutorial.</p>

<h2>Rust-Graphics</h2>

<p><em>Rust-Graphics</em> is a 2d graphics API that can draw to any graphical backend.
Right now, the project only provides an implementation for OpenGL, but in
theory, any graphical
backend that implements the Rust-Graphics backend interface could be used
without any changes to your drawing code.</p>

<p>The <em>Rust-Graphics</em> drawing API is based on the pure functional idea of
building more complicated structures out of simpler ones without performing
any mutation.</p>

<p>A code snippit is worth a thousand words, so here&#39;s <em>Rust-Graphics</em> in action:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Make a drawing context</span>
<span class="kd">let</span> <span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Context</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">window_width</span><span class="p">,</span> <span class="n">window_height</span><span class="p">);</span>
<span class="c1">// Clear the screen with white</span>
<span class="n">c</span><span class="p">.</span><span class="n">rgb</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">).</span><span class="n">draw</span><span class="p">(</span><span class="n">backend</span><span class="p">);</span>
<span class="c1">// Draw a red rectangle in the upper left corner of the screen</span>
<span class="n">c</span><span class="p">.</span><span class="n">rect</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">50.0</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">).</span><span class="n">rgb</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">).</span><span class="n">draw</span><span class="p">(</span><span class="n">backend</span><span class="p">);</span>
</code></pre></div>
<p>In the api example, <code>backend</code> is a <em>Rust-Graphics</em> graphical backend that
in practice will probably be an OpenGL context.</p>

<h2>Rust-Image</h2>

<p>Odds are that your game will have some images as assets to be drawn to the
screen.  Fortunately, <em>Rust-Image</em> has you covered, with decoders and encoders
for <code>png</code>, <code>jpeg</code>, <code>gif</code>, and <code>webp</code>.  Example code for this library isn&#39;t
particularly interesting: it does exactly what you expect exactly how you would
expect.</p>

<h1>Inter-Package Dependencies</h1>

<p>You might have noticed that for both <em>Piston</em> and <em>Rust-Graphics</em> there was
a lot of talk about being independent from &quot;backends&quot;.  This is because both
projects use interfaces heavily in order to eliminate hard dependencies.</p>

<p>For example, <em>Piston</em> has a <code>GameWindow</code> trait with <em>no implementations</em>.
All of the rest of the code in <em>Piston</em> simply operates on <em>a</em> <code>GameWindow</code>.</p>

<p>Because SDL2 and GLFW are great libraries for window and event logic, a game
developer can choose either one and depend on the interface implementation
that the Piston Developers have already written for that backend.</p>

<p>A dependency tree for a simple project might look like this.</p>

<ul>
<li>My Game

<ul>
<li>piston</li>
<li>graphics</li>
<li>sdl2<em>game</em>window</li>
<li>sdl2</li>
<li>piston</li>
<li>gl</li>
<li>opengl_graphics</li>
<li>gl</li>
<li>graphics</li>
<li>image</li>
</ul></li>
</ul>

<p>In that project, the developer wanted to use the packages <code>piston</code> and
<code>graphics</code>.  However, both of those projects require a backend
implementation.  The developer chose <code>sdl2</code> for the <code>piston</code> backend
and OpenGL for the <code>graphics</code> backend.</p>

<p>Now, without being exposed to raw SDL2 or OpenGL, the programmer can use
the well idiomatically designed <em>Piston</em> and <em>rust-graphics</em> libraries.</p>

</div>

        </div>
    </body>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>
</html>
