<!DOCTYPE html>
<html>
    <head>
        <title> A Rusty Microbenchmark </title>
        <link rel="stylesheet" type="text/css" href="/css/style.css">
        <link rel="stylesheet" type="text/css" href="/css/code.css">
    <link href="http://fonts.googleapis.com/css?family=Cardo:700" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">
    </head>
    <body>
        <div id="wrapper">
            <header>
    <h1> A Rusty Microbenchmark </h1>
    <h2> Rust eating C food </h2>
    <div id="byline"> <span> By </span> <span> Ty Overby </span> </div>
</header>

<div id="post">
    <p>As a totally contrived example, I will be computing the expression</p>

<p>
    $ \sum_{i=0}^{1,000,000,000} \begin{cases} i/2 + 2 & \text{if } i \% 2 = 0 \\\\ 0 & \text{otherwise} \end{cases}$
</p>

<p>in both C and Rust to see how close in performance Rust can get to C while still being written in
an idiomatic pure-functional style.</p>

<h1>Rust</h1>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">iter</span><span class="o">::</span><span class="nb">range</span><span class="p">;</span>

<span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="k">mut</span> <span class="n">iterator</span> <span class="o">=</span>
      <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="k">i32</span><span class="p">,</span> <span class="mi">1_000_000_000</span><span class="k">i32</span><span class="p">)</span>
        <span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="o">*</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
    <span class="kd">let</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">iterator</span><span class="p">.</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>
    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h1>C</h1>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h1>Benchmark / Analysis</h1>

<p>Both of these implementations are flawed in various ways:
1. Using 32-bit integers means that the computation overflows very quickly
2. Finding the even numbers doesn&#39;t require a filter or if statement when you
   could only look at every other number to begin with.
3. The rust implementation should do both map steps at once.</p>

<p>These issues were kept despite their flaws:
1. To avoid slower number operations;
2. To test how well the compilers handle branching at the CPU level; and
3. To see if Rust is able to optimize away the additional map.</p>

<p>I was incredibly surprised to see that on my machine, Rust was able to
outperform C reliably.</p>

<h2>Rust</h2>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ rustc iter.rs  --opt-level 3
$ time ./iter
-1583310976

real    0m0.884s
user    0m0.872s
sys     0m0.004s
</code></pre></div>
<h2>C</h2>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ gcc test.c -std=c99 -O3
$ time ./a.out
-1583310976

real    0m1.398s
user    0m1.388s
sys     0m0.004s
</code></pre></div>
<p>I&#39;m sure that there are ways to get the C version faster, but the only
important takeaway from this 5 second experiment is that the Rust compiler does
a damn good job of providing abstractions that hit really close to the metal.</p>

</div>

        </div>
    </body>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>
</html>
