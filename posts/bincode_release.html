



<!doctype html>

<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta charset="UTF-8">
        <title> Bincode 1.0.0 </title>
        <link href="https://fonts.googleapis.com/css?family=Montserrat:700|Raleway:100|Roboto+Condensed:300|Roboto|Roboto+Mono" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-beta1/katex.min.css" integrity="sha384-VEnyslhHLHiYPca9KFkBB3CMeslnM9CzwjxsEbZTeA21JBm7tdLwKoZmCt3cZTYD" crossorigin="anonymous" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-beta1/katex.min.js" integrity="sha384-O4hpKqcplNCe+jLuBVEXC10Rn1QEqAmX98lKAIFBEDxZI0a+6Z2w2n8AEtQbR4CD" crossorigin="anonymous"></script>
        <style>

html, body, header {
    margin: 0;
    padding: 0;
}

header {
    position: relative;
    min-height: 100vh;

    background: url(../images/snowy-mountains.jpeg);

    background-size: cover;
    text-align: center;

    display: flex;
    flex-direction: column;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
}

header #header-container {
    background-color: red;
}

header #title {
    font-family: 'Montserrat', sans-serif;
    font-weight: bold;
    font-size: 3em;
    text-transform: uppercase;
}

header #subtitle {
    font-family: 'Raleway', sans-serif;
    font-weight: bold;
    font-size: 2em;
}

.black {
    color: black;
    text-shadow: 0px 0px 4px white;
}

.white {
    color: white;
    text-shadow: 0px 0px 4px black;
}

section {
    padding: 30px;
    font-family: 'Roboto', sans-serif;
    font-weight: 500;
    width: 800px;
    margin-left: auto;
    margin-right: auto;
    font-size: 1.05em;
    line-height: 1.5em;
    text-align: justify;
    text-justify: distribute;
}

@media only screen and (max-width: 860px) {
    section {
        width: calc(100vw - 60px);
    }
}

h1, h2, h3, h4 {
    font-family: 'Roboto', sans-serif;
    font-weight: bold;
    color: rgb(10, 10, 60);
    text-justify: none;
}

h1, h2 {
    font-size: 2em;
}

h3 {
    font-size: 1.3em;
}

code {
    font-family: 'Roboto Mono';
    font-size: 0.9em;
}

.kw {
    font-weight: bold;
}

th {
    text-align: center;
}

blockquote {
    border-left: 3px solid green;
    padding-left: 20px;
    margin-left: 0;
    color: darkgreen;
}

div#toc ul {
    list-style: none;
}
div#toc>ul {
    padding-left: 0;
}

        </style>
    </head>
    <body>
        <header>
            <span id="title" class=black> Bincode 1.0.0 </span>
            <span id="subtitle" class=black> Fucking Finally </span>
        </header>
        <section>

<div id="toc">
<h3> Table Of Contents </h3>
<ul>
<li><a href="#what-is-bincode">What is Bincode?</a></li>
<li><a href="#how-does-bincode-work">How does Bincode work?</a><ul>
<li><a href="#encoding-numbers">Encoding Numbers</a></li>
<li><a href="#encoding-strings">Encoding Strings</a></li>
<li><a href="#encoding-structs">Encoding Structs</a></li>
<li><a href="#encoding-enums">Encoding Enums</a></li>
</ul></li>
<li><a href="#should-i-use-bincode">Should I use Bincode?</a></li>
<li><a href="#the-future-of-bincode">The Future of Bincode</a></li>
</ul>
</div>
<p>Today <a href="https://github.com/tyoverby/bincode">Bincode</a> hits 1.0.0! Before we truly get started, a brief history:</p>
<ul>
<li>Sep 15, 2014: First prototype - then named <code>writer_encoder</code> - was written on a plane. I was too poor at the time to pay for in-flight wifi so I wasn’t able to download any other serializers.</li>
<li>Oct 27, 2014: Rename to <code>bincode</code>.</li>
<li>Apr 05, 2015: Initial port to serde written by <a href="https://github.com/erickt">erickt</a>. Prior to this, we were using <a href="https://github.com/rust-lang-deprecated/rustc-serialize">rustc-serialize</a>.</li>
<li>Aug 8, 2015: Servo starts using bincode in <a href="https://crates.io/crates/ipc-channel">ipc-channel</a>!</li>
<li>Jan 12, 2016: <a href="https://github.com/google/tarpc">Tarpc</a> starts using bincode!</li>
<li>Apr 21, 2017: Serde hits 1.0! Serde maintainer <a href="https://github.com/dtolnay">dtolnday</a> ports bincode to use the new Serde APIs.</li>
</ul>
<p>Many thanks to <a href="https://github.com/TyOverby/bincode/graphs/contributors">everyone who has contributed</a>. I deeply appreciate the help.</p>
<h1 id="what-is-bincode">What is Bincode?</h1>
<p>At it’s root, Bincode is a serializer implementation for Serde. If you stick a <code>#[derive(Deserialize, Serialize)]</code> on your struct, you can use Bincode to efficiently serialize and deserialize those structs to and from bytes.</p>
<blockquote>
<p>If Bincode is just another serializer implementation, what sets it apart from all the others?</p>
</blockquote>
<p>Bincode is a bit weird in that it’s a format that was built specifically for the Rust serialization ecosystem. Its tight coupling with Serde allows Bincode to be very fast and serialize to very small payloads.</p>
<h1 id="how-does-bincode-work">How does Bincode work?</h1>
<p>Bincode achieves its speed and size wins is by choosing to not encode structure into the serialized output. It relies on the fact that <code>#[derive(Deserialize, Serialize)]</code> implementation of the Serde traits deserializes fields in <em>exactly the same order</em> as it serialized them. This means that if you implement those traits by hand, you need to uphold this invariant as well.</p>
<p>Because Bincode leaves out this extraneous structure information, a struct serialized with Bincode is often smaller than it was in memory!</p>
<p>Let’s take a look at how Bincode serializes some common structures.</p>
<h3 id="encoding-numbers">Encoding Numbers</h3>
<p>All the Rust numbers are encoded directly into the output in little-endian format by default.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">use</span> bincode::<span class="op">{</span>serialize, deserialize<span class="op">}</span>;</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">let</span> bytes: <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt; = serialize(&amp;<span class="dv">123456789u32</span>).unwrap();</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="co">// a 4-byte u32 gets serialized to 4 bytes.</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="pp">assert_eq!</span>(bytes.len(), <span class="dv">4</span>);</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">let</span> number: <span class="dt">u32</span> = deserialize(&amp;bytes).unwrap();</a></code></pre></div>
<p><img src="../images/bincode/u32.svg" style="padding: 5px; background:rgb(240, 240, 240)"/></p>
<h3 id="encoding-strings">Encoding Strings</h3>
<p>Strings are serialized by first serializing the length and then serializing the byte content of the string.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">use</span> bincode::<span class="op">{</span>serialize, deserialize<span class="op">}</span>;</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">let</span> bytes: <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt; = serialize(&amp;<span class="dt">String</span>::from(<span class="st">&quot;hello!&quot;</span>)).unwrap();</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">let</span> string: <span class="dt">String</span> = deserialize(&amp;bytes).unwrap();</a></code></pre></div>
<p><img src="../images/bincode/string.svg" style="padding: 5px; background:rgb(240, 240, 240)"/></p>
<h3 id="encoding-structs">Encoding Structs</h3>
<p>When serializing a struct, each field is serialized in order of its declaration in the struct. No additional field information is encoded.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">use</span> bincode::<span class="op">{</span>serialize, deserialize<span class="op">}</span>;</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="at">#[</span>derive<span class="at">(</span>Serialize<span class="at">,</span> Deserialize<span class="at">)]</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">struct</span> Person <span class="op">{</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    age: <span class="dt">u32</span>,</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    name: <span class="dt">String</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="kw">let</span> person = Person <span class="op">{</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    <span class="co">// hey, making these svgs is hard, I&#39;m reusing values for my own sanity.</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    age: <span class="dv">123456789</span>,</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    name: <span class="dt">String</span>::from(<span class="st">&quot;hello!&quot;</span>),</a>
<a class="sourceLine" id="cb3-13" data-line-number="13"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb3-14" data-line-number="14"></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"><span class="kw">let</span> bytes: <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt; = serialize(&amp;person).unwrap();</a>
<a class="sourceLine" id="cb3-16" data-line-number="16"><span class="kw">let</span> person_2: Person = deserialize(&amp;bytes).unwrap()A;</a></code></pre></div>
<p><img src="../images/bincode/struct.svg" style="padding: 5px; background:rgb(240, 240, 240)"/></p>
<h3 id="encoding-enums">Encoding Enums</h3>
<p>Enums are serialized as a tag (u32) followed by their fields serialized in declaration order.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">use</span> bincode::<span class="op">{</span>serialize, deserialize<span class="op">}</span>;</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="at">#[</span>derive<span class="at">(</span>Serialize<span class="at">,</span> Deserialize<span class="at">)]</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw">struct</span> NumberOrString <span class="op">{</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    Number(<span class="dt">u32</span>),</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    <span class="dt">String</span>(<span class="dt">String</span>),</a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">let</span> num = NumberOrString::Number(<span class="dv">123456789</span>);</a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="kw">let</span> string = NumberOrString::<span class="dt">String</span>(<span class="st">&quot;hello!&quot;</span>);</a>
<a class="sourceLine" id="cb4-11" data-line-number="11"></a>
<a class="sourceLine" id="cb4-12" data-line-number="12"><span class="kw">let</span> bytes_num: <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt; = serialize(&amp;num).unwrap();</a>
<a class="sourceLine" id="cb4-13" data-line-number="13"><span class="kw">let</span> bytes_string: <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt; = serialize(&amp;string).unwrap();</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="kw">let</span> num_out: NumberOrString = deserialize(&amp;bytes_num);</a>
<a class="sourceLine" id="cb4-16" data-line-number="16"><span class="kw">let</span> num_out: NumberOrString = deserialize(&amp;bytes_string);</a></code></pre></div>
<p><img src="../images/bincode/enum.svg" style="padding: 5px; background:rgb(240, 240, 240)"/></p>
<h1 id="should-i-use-bincode">Should I use Bincode?</h1>
<p>Bincode is great for very specific serialization tasks, but is less than ideal for others. To help you decide if you should use it or not, I’ve provided a helpful cost benefit analysis below.</p>
<p><strong>Pros</strong></p>
<ul>
<li>Fast</li>
<li>Small serialized size</li>
<li>Configurable options for improving speed and size even further!
<ul>
<li>Choose between endianness for integers</li>
<li>Set message size limits for Denial Of Service protection</li>
<li>Upcoming configurations
<ul>
<li>Variable sized integers for lengths and enum variants</li>
<li>Null terminated strings</li>
</ul></li>
</ul></li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Not human readable</li>
<li><strong>Serialized data can not be read if structure changes</strong>
<ul>
<li>No reordering fields</li>
<li>No adding / removing fields</li>
</ul></li>
</ul>
<p>The “no structure changes” drawback can not be understated. If your program requires backwards-compatible data representations, take a look at other formats such as <a href="https://github.com/google/protobuf">ProtoBuf</a> or <a href="https://capnproto.org/">Cap’n Proto</a>.</p>
<p>However, there are many areas where those limitations aren’t actual issues! The best example of this is <a href="https://crates.io/crates/ipc-channel">ipc-channel</a> which uses bincode to send structs across the process boundary. When both processes are the same binary, there’s no need to worry about the struct definitions being different.</p>
<p>Another popular use case would be video games. Networked video games rarely permit players of different versions of a game to connect to each other. Similarly to the ipc-channel example, if every player is running the same build, there is no need to worry about back-compat issues.</p>
<h1 id="the-future-of-bincode">The Future of Bincode</h1>
<p>Bincode 1.0.0 is at a point where I feel comfortable recommending the project and am happy overall with the library ergonomics.</p>
<p>Being both a library and an ad-hoc data format, Bincode has some interesting compatibility requirements.</p>
<ul>
<li>The library itself must obey semver (as all crates should).</li>
<li>Data encoded by one version of Bincode should be readable by future versions of Bincode.</li>
</ul>
<p>Both of these are fairly easy to achieve while also permitting Bincode to evolve through the use of configuration options.</p>

<script>
    var maths = document.querySelectorAll(".math");
    for (var i = 0; i < maths.length; i++) {
        var text = maths[i].innerText;
        maths[i].innerText = "";
        katex.render(text, maths[i]);
    }
</script>

</section>
</body>

</html>


