<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="" >

<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />   <meta name="author" content="Ty Overby" />     <title>Bincode 1.0.0</title>

  <link href="https://fonts.googleapis.com/css?family=Montserrat:700|Raleway:100|Roboto+Condensed:300|Roboto|Roboto+Mono" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css" />
  <style type="text/css">
    code {
      white-space: pre-wrap;
    }

    span.smallcaps {
      font-variant: small-caps;
    }

    span.underline {
      text-decoration: underline;
    }

    div.column {
      display: inline-block;
      vertical-align: top;
      width: 50%;
    }

    
  </style>
    <style type="text/css">
    a.sourceLine { display: inline-block; line-height: 1.25; }
    a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
    a.sourceLine:empty { height: 1.2em; position: absolute; }
    .sourceCode { overflow: visible; }
    code.sourceCode { white-space: pre; position: relative; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    code.sourceCode { white-space: pre-wrap; }
    a.sourceLine { text-indent: -1em; padding-left: 1em; }
    }
    pre.numberSource a.sourceLine
      { position: relative; }
    pre.numberSource a.sourceLine:empty
      { position: absolute; }
    pre.numberSource a.sourceLine::before
      { content: attr(data-line-number);
        position: absolute; left: -5em; text-align: right; vertical-align: baseline;
        border: none; pointer-events: all;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  }
    @media screen {
    a.sourceLine::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
    
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>

<body>
     <header class="" style="background-image: url(../images/snowy-mountains.jpeg)">
    <span class="title">Bincode 1.0.0</span>
         <span class="author">-Ty Overby</span>
       </header>
  <section>
    Today <a href="https://github.com/tyoverby/bincode">Bincode</a> hits 1.0.0! Before we truly get started, a brief history:
 <table>
 <tr>
 <td style="min-width: 7em;">
 Sep 15 2014
 </td>
 <td>
 First prototype - then named <code>writer_encoder</code> - was written while I was on a plane with no wifi.
 </tr>
 <tr>
 <td>
 Oct 27 2014
 </td>
 <td>
 Rename to <code>bincode</code>
 </td>
 </tr>
 <tr>
 <td>
 Apr 05 2015
 </td>
 <td>
 Initial port to serde written by <a href="https://github.com/erickt">erickt</a> Prior to this, we were using <a href="https://github.com/rust-lang-deprecated/rustc-serialize">rustc-serialize</a>
 </td>
 </tr>
 <tr>
 <td>
 Aug 08 2015
 </td>
 <td>
 <div class="line-block">
 Servo starts using bincode in <a href="https://crates.io/crates/ipc-channel">ipc-channel</a>
 </div>
 </td>
 </tr>
 <tr>
 <td>
 Jan 12 2016
 </td>
 <td>
 <a href="https://github.com/google/tarpc">Tarpc</a> starts using bincode
 </td>
 </tr>
 <tr>
 <td>
 Apr 21 2017
 </td>
 <td>
 Serde hits 1.0! Serde maintainer <a href="https://github.com/dtolnay">dtolnay</a> ports bincode to use the new Serde APIs
 </td>
 </tr>
 </table>
 Many thanks to <a href="https://github.com/TyOverby/bincode/graphs/contributors">everyone who has contributed</a>. I deeply appreciate the help.    <h1> Table of Contents </h1>
  <nav id="TOC">
    <ul>
    <li><a href="#what-is-bincode">What is Bincode?</a></li>
    <li><a href="#how-does-bincode-work">How does Bincode work?</a><ul>
    <li><a href="#encoding-numbers">Encoding Numbers</a></li>
    <li><a href="#encoding-strings">Encoding Strings</a></li>
    <li><a href="#encoding-structs">Encoding Structs</a></li>
    <li><a href="#encoding-enums">Encoding Enums</a></li>
    </ul></li>
    <li><a href="#should-i-use-bincode">Should I use Bincode?</a></li>
    <li><a href="#the-future-of-bincode">The Future of Bincode</a></li>
    </ul>
  </nav>
   <h1 id="what-is-bincode">What is Bincode?</h1>
<p>At it’s root, Bincode is a serializer implementation for Serde. If you stick a <code>#[derive(Deserialize, Serialize)]</code> on your struct, Bincode can efficiently serialize and deserialize those structs to and from bytes.</p>
<blockquote>
<p>If Bincode is just another serializer implementation, what sets it apart from all the others?</p>
</blockquote>
<p>Bincode is unique in that it’s a format that was built specifically for the Rust serialization ecosystem. Tight coupling with Serde allows Bincode to be very fast and serialize to very small payloads.</p>
<h1 id="how-does-bincode-work">How does Bincode work?</h1>
<p>Bincode achieves its speed and size wins is by not encoding structure information into the serialized output. It relies on the fact that <code>#[derive(Deserialize, Serialize)]</code> implementations of the Serde traits deserializes fields in <em>exactly the same order</em> as it serialized them. (If you implement those traits by hand, you need to uphold this invariant as well.)</p>
<p>Because Bincode leaves out this extraneous structure information, a struct serialized with Bincode is often smaller than it was in memory! Let’s take a look at how Bincode serializes some common structures.</p>
<h3 id="encoding-numbers">Encoding Numbers</h3>
<p>All the Rust numbers are encoded directly into the output in little-endian format by default.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">use</span> bincode::<span class="op">{</span>serialize, deserialize<span class="op">}</span>;</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">let</span> bytes: <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt; = serialize(&amp;<span class="dv">123456789u32</span>)?;</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="co">// a 4-byte u32 gets serialized to 4 bytes.</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="pp">assert_eq!</span>(bytes.len(), <span class="dv">4</span>);</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">let</span> number: <span class="dt">u32</span> = deserialize(&amp;bytes)?;</a></code></pre></div>
<p><img src="../images/bincode/u32.svg" /></p>
<h3 id="encoding-strings">Encoding Strings</h3>
<p>Strings are serialized by first serializing the length and then serializing the byte content of the string.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">use</span> bincode::<span class="op">{</span>serialize, deserialize<span class="op">}</span>;</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">let</span> bytes: <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt; = serialize(&amp;<span class="dt">String</span>::from(<span class="st">&quot;hello!&quot;</span>))?;</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">let</span> string: <span class="dt">String</span> = deserialize(&amp;bytes)?;</a></code></pre></div>
<p><img src="../images/bincode/string.svg" /></p>
<h3 id="encoding-structs">Encoding Structs</h3>
<p>When serializing a struct, each field is serialized in order of its declaration in the struct. No additional field information is encoded.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">use</span> bincode::<span class="op">{</span>serialize, deserialize<span class="op">}</span>;</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="at">#[</span>derive<span class="at">(</span>Serialize<span class="at">,</span> Deserialize<span class="at">)]</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">struct</span> Person <span class="op">{</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    age: <span class="dt">u32</span>,</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    name: <span class="dt">String</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="kw">let</span> person = Person <span class="op">{</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    <span class="co">// hey, making these svgs is hard, I&#39;m reusing values for my own sanity.</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    age: <span class="dv">123456789</span>,</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    name: <span class="dt">String</span>::from(<span class="st">&quot;hello!&quot;</span>),</a>
<a class="sourceLine" id="cb3-13" data-line-number="13"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb3-14" data-line-number="14"></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"><span class="kw">let</span> bytes: <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt; = serialize(&amp;person)?;</a>
<a class="sourceLine" id="cb3-16" data-line-number="16"><span class="kw">let</span> person_2: Person = deserialize(&amp;bytes)?;</a></code></pre></div>
<p><img src="../images/bincode/struct.svg" /></p>
<h3 id="encoding-enums">Encoding Enums</h3>
<p>Enums are serialized as a tag (u32) followed by their fields serialized in declaration order.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">use</span> bincode::<span class="op">{</span>serialize, deserialize<span class="op">}</span>;</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="at">#[</span>derive<span class="at">(</span>Serialize<span class="at">,</span> Deserialize<span class="at">)]</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw">struct</span> NumberOrString <span class="op">{</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    Number(<span class="dt">u32</span>),</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    <span class="dt">String</span>(<span class="dt">String</span>),</a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">let</span> num = NumberOrString::Number(<span class="dv">123456789</span>);</a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="kw">let</span> string = NumberOrString::<span class="dt">String</span>(<span class="st">&quot;hello!&quot;</span>);</a>
<a class="sourceLine" id="cb4-11" data-line-number="11"></a>
<a class="sourceLine" id="cb4-12" data-line-number="12"><span class="kw">let</span> bytes_num: <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt; = serialize(&amp;num)?;</a>
<a class="sourceLine" id="cb4-13" data-line-number="13"><span class="kw">let</span> bytes_string: <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt; = serialize(&amp;string)?;</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="kw">let</span> num_out: NumberOrString = deserialize(&amp;bytes_num)?;</a>
<a class="sourceLine" id="cb4-16" data-line-number="16"><span class="kw">let</span> num_out: NumberOrString = deserialize(&amp;bytes_string)?;</a></code></pre></div>
<p><img src="../images/bincode/enum.svg" /></p>
<h1 id="should-i-use-bincode">Should I use Bincode?</h1>
<p>Bincode is great for very specific serialization tasks, but is less than ideal for others. To help you decide if you should use it or not, I’ve provided a helpful cost benefit analysis below.</p>
<p><strong>Pros</strong></p>
<ul>
<li>Fast</li>
<li>Small serialized size</li>
<li>Configurable options for improving speed and size even further!
<ul>
<li>Choose between endianness for integers</li>
<li>Set message size limits for Denial Of Service protection</li>
<li>Upcoming configurations
<ul>
<li>Variable sized integers for lengths and enum variants</li>
<li>Null terminated strings</li>
</ul></li>
</ul></li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Not human readable</li>
<li>No cross-language support</li>
<li><strong>Serialized data can not be read if structure changes</strong>
<ul>
<li>No reordering fields</li>
<li>No adding / removing fields</li>
</ul></li>
</ul>
<p>The “no structure changes” drawback can not be understated. If your program requires backwards-compatible data representations, take a look at other formats such as <a href="https://github.com/google/protobuf">ProtoBuf</a> or <a href="https://capnproto.org/">Cap’n Proto</a>.</p>
<p>However, there are many areas where those limitations aren’t actual issues! The best example of this is <a href="https://crates.io/crates/ipc-channel">ipc-channel</a> which uses bincode to send structs across the process boundary. When both processes are the same binary, there’s no need to worry about the struct definitions being different.</p>
<p>Another popular use case would be video games. Networked video games rarely permit players of different versions of a game to connect to each other. Similarly to the ipc-channel example, if every player is running the same build, there is no need to worry about back-compat issues.</p>
<h1 id="the-future-of-bincode">The Future of Bincode</h1>
<p>Bincode 1.0.0 is at a point where I feel comfortable recommending the project and am happy overall with the library ergonomics.</p>
<p>Being both a library and an ad-hoc data format, Bincode has some interesting compatibility requirements.</p>
<ul>
<li>The library itself must obey semver (as all crates should).</li>
<li>Data encoded by one version of Bincode should be readable by future versions of Bincode.</li>
</ul>
<p>Both of these are fairly easy to achieve while also permitting Bincode to evolve through the use of configuration options. As new language features come online (I’m looking at you impl-trait), bincode will be re-released with major version changes.</p> 

  </section>
</body>
</html>
