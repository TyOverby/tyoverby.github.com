



<html>
    <head>
        <title> Rust Speed </title>
    </head>
    <style>

html, body {
    margin: 0;
    padding: 0;
}


.sourceCode .kw { color: #268BD2; }

.sourceCode .dt { color: #268BD2; }

.sourceCode .dv, .sourceCode .bn, .sourceCode .fl { color: #D33682; }

.sourceCode .ch { color: #DC322F; }

.sourceCode .st { color: #2AA198; }

.sourceCode .co { color: #93A1A1; }

.sourceCode .ot { color: #A57800; }

.sourceCode .al { color: #CB4B16; font-weight: bold; }

.sourceCode .fu { color: #268BD2; }

.sourceCode .re { }

.sourceCode .er { color: #D30102; font-weight: bold; }*/

    </style>
    <body>

<p>As a totally contrived example, I will be computing the expression</p>
<p>
<pre><code>$ \sum_{i=0}^{1,000,000,000} \begin{cases} i/2 + 2 &amp; \text{if } i \% 2 = 0 \\\\ 0 &amp; \text{otherwise} \end{cases}$</code></pre>
</p>
<p>in both C and Rust to see how close in performance Rust can get to C while still being written in an idiomatic pure-functional style.</p>
<h1 id="rust">Rust</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::iter::range;

<span class="kw">fn</span> main() {
    <span class="kw">let</span> <span class="kw">mut</span> iterator =
      range(<span class="dv">0i32</span>, <span class="dv">1_000_000_000i32</span>)
        .filter(|x| *x % <span class="dv">2</span> == <span class="dv">0</span>)
        .map(|x| x / <span class="dv">2</span>)
        .map(|x| x + <span class="dv">2</span>);
    <span class="kw">let</span> ans = iterator.fold(<span class="dv">0</span>, |a, b| a + b);
    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, ans);
}</code></pre></div>
<h1 id="c">C</h1>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">void</span> main(<span class="dt">void</span>) {
    <span class="dt">int</span> counter = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">1000000000</span>; i++) {
        <span class="kw">if</span> (i % <span class="dv">2</span> == <span class="dv">0</span>) {
            counter += (i / <span class="dv">2</span>) + <span class="dv">2</span>;
        }
    }
    printf(<span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span>, counter);
}</code></pre></div>
<h1 id="benchmark-analysis">Benchmark / Analysis</h1>
<p>Both of these implementations are flawed in various ways: 1. Using 32-bit integers means that the computation overflows very quickly 2. Finding the even numbers doesn't require a filter or if statement when you could only look at every other number to begin with. 3. The rust implementation should do both map steps at once.</p>
<p>These issues were kept despite their flaws: 1. To avoid slower number operations; 2. To test how well the compilers handle branching at the CPU level; and 3. To see if Rust is able to optimize away the additional map.</p>
<p>I was incredibly surprised to see that on my machine, Rust was able to outperform C reliably.</p>
<h2 id="rust-1">Rust</h2>
<pre><code>$ rustc iter.rs  --opt-level 3
$ time ./iter
-1583310976

real    0m0.884s
user    0m0.872s
sys     0m0.004s</code></pre>
<h2 id="c-1">C</h2>
<pre><code>$ gcc test.c -std=c99 -O3
$ time ./a.out
-1583310976

real    0m1.398s
user    0m1.388s
sys     0m0.004s</code></pre>
<p>I'm sure that there are ways to get the C version faster, but the only important takeaway from this 5 second experiment is that the Rust compiler does a damn good job of providing abstractions that hit really close to the metal.</p>

    </body>
</html>


