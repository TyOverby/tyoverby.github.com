<!DOCTYPE html>
<html lang="en">
  <head>
    <title>What is the Piston Project</title>
    <link href="http://fonts.googleapis.com/css?family=Cardo:700" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="./style.css">
    <link rel="stylesheet" type="text/css" href="./atelier-lakeside.light.css">
  </head>
  <body>
    <div id="wrapper">
      <header>
        <h1>What is the Piston Project</h1>
        <h2></h2>
        <div id="byline"><span>By</span><span>Ty Overby</span></div>
      </header>
      <article><p>The Piston Project is a collection of game programming libraries that make it
easy to develop games with the Rust programming language.  These libraries are
made to be easily combined with eachother, however it is just as easy to add
non-piston libraries to your stack.</p>
<p>Let&#39;s take a look at a few of the libraries in the Piston Project.</p>
<h2 id="piston">Piston</h2>
<p>As any native game developer knows, getting a window open and a triangle on
the screen can be hell.  The titular project <strong>Piston</strong> helps with the first
of those by providing a clean, backend-independent windowing API.  The API
can be backed by SDL2, GLFW, or any other system that another party
decides to write that implements the <strong>Piston</strong> API.</p>
<p>Aside from just creating a window, <strong>Piston</strong> exposes an interface for
keyboard and mouse events, making interacting with the window just as easy
as opening it.</p>
<p>If you decide,</p>
<p>Let&#39;s take a look at the code that it takes to get a window up on the
screen.</p>
<pre><code class="lang-rust"><span class="hljs-keyword">extern</span> crate piston;
<span class="hljs-keyword">extern</span> crate sdl2_game_window;

<span class="hljs-comment">// This would contain our game state</span>
<span class="hljs-keyword">struct</span> App;

<span class="hljs-comment">// This would contain our game behavior</span>
<span class="hljs-keyword">impl</span> Game <span class="hljs-keyword">for</span> App {}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span>(</span>) {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> window = GameWindowSDL2::new(
        GameWindowSettings {
            title: <span class="hljs-string">"test"</span>.to_string(),
            size: [<span class="hljs-number">800</span>, <span class="hljs-number">400</span>],
            fullscreen: <span class="hljs-keyword">false</span>,
            exit_on_esc: <span class="hljs-keyword">true</span>
        }
    );

    <span class="hljs-keyword">let</span> game_iter_settings = GameIteratorSettings {
        updates_per_second: <span class="hljs-number">120</span>,
        max_frames_per_second: <span class="hljs-number">60</span>
    };
    App.run(&amp;<span class="hljs-keyword">mut</span> window, &amp;game_iter_settings);
}
</code></pre>
<p>You&#39;ll notice that the SDL2 backend was used for this example, how and why
we use it is a bit out of scope for this introduction, but will be covered
by the tutorial.</p>
<h2 id="rust-graphics">Rust-Graphics</h2>
<p><strong>Rust-Graphics</strong> is a 2d graphics API that can draw to any graphical backend.
Right now, the project only supports OpenGL, but in theory, any graphical
backend that implements the Rust-Graphics backend interface could be used
without any changes to your drawing.</p>
<p>The <strong>Rust-Graphics</strong> drawing API is based on the pure functional idea of
building more complicated structures out of simpler ones without performing
any mutation.</p>
<p>A code snippit is worth a thousand words, so here&#39;s <strong>Rust-Graphics</strong> in action:</p>
<pre><code class="lang-rust"><span class="hljs-comment">// Make a drawing context</span>
<span class="hljs-keyword">let</span> c = &amp;Context::abs(window_width, window_height);
<span class="hljs-comment">// Clear the screen with white</span>
c.rgb(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>).draw(backend);
<span class="hljs-comment">// Draw a red rectangle in the upper left corner of the screen</span>
c.rect(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>,  <span class="hljs-number">50.0</span>, <span class="hljs-number">50.0</span>).rgb(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>).draw(backend);
</code></pre>
<p>In the api example, <code>backend</code> is a <strong>Rust-Graphics</strong> graphical backend that
in practice will probably be an OpenGL context.</p>
<h2 id="rust-image">Rust-Image</h2>
<p>Odds are that your game will have some images as assets to be drawn into the
game.  Fortunately, <strong>Rust-Image</strong> has you covered, with decoders and encoders
for <code>png</code>, <code>jpeg</code>, <code>gif</code>, and <code>webp</code>.  Example code for this library isn&#39;t
particularly interesting: it does exactly what you expect exactly how you would
expect.</p>
<h1 id="inter-package-dependencies">Inter-Package Dependencies</h1>
<p>You might have noticed that for both <strong>Piston</strong> and <strong>Rust-Graphics</strong> there was
a lot of talk about being independent from &quot;backends&quot;.  This is because both
projects use interfaces heavily in order to minimize hard dependencies.</p>
<p>For example, <strong>Piston</strong> has a <code>GameWindow</code> trait with <em>no implementations</em>.
All of the rest of the code in <strong>Piston</strong> simply operates on <em>a</em> <code>GameWindow</code>.</p>
<p>Because SDL2 and GLFW are great libraries for window and event logic, a game
developer can choose either one and depend on the interface implementation
that the Piston Developers have already written for that choice.</p>
<p>Expanding on that example, a dependency tree might look like this.</p>
<ul>
<li>My Game<ul>
<li>piston</li>
<li>graphics</li>
<li>sdl2_game_window<ul>
<li>sdl2</li>
<li>piston</li>
<li>gl</li>
</ul>
</li>
<li>opengl_graphics<ul>
<li>gl</li>
<li>graphics</li>
<li>image</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>In that project, the developer wanted to use the packages <code>piston</code> and
<code>graphics</code>.  However, both of those projects are useless without a backend
implementation.  The developer chose <code>sdl2</code> for the <code>piston</code> backend
and OpenGL for the <code>graphics</code> backend.</p>
<p>Now without being exposed to raw SDL2 or OpenGL, the programmer can use
the well idiomatically designed <strong>Piston</strong> and <strong>rust-graphics</strong> libraries.</p>
</article>
    </div>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>
  </body>
</html>